#!/usr/bin/env bash
set -euo pipefail

# dot — generic, repo-agnostic CLI inspired by chezmoi
#
# This file contains only reusable orchestration logic. It discovers and runs
# repo-provided scripts under scripts/<platform>/<subcommand>/*.sh.
# No repo-specific content lives here; you can copy this file to other repos.
#
# Subcommands:
#   ./dot apply  [--dry-run] [--target DIR]
#   ./dot restow [--dry-run] [--target DIR]
#   ./dot delete [--dry-run] [--target DIR]
#   ./dot update [--dry-run] [--target DIR]
#   ./dot diff   [--target DIR]
#   ./dot test
#
# Each subcommand runs hook scripts (sorted) from these locations, in order:
#   scripts/common/<subcommand>/*.sh
#   scripts/unix/<subcommand>/*.sh        # on macOS or Linux
#   scripts/darwin/<subcommand>/*.sh      # on macOS
#   scripts/linux/<subcommand>/*.sh       # on Linux
#
# Environment passed to hooks:
#   DOT_CMD, DOT_OS, DOT_REPO, DOT_TARGET, DOT_DRYRUN ("1" if --dry-run)
#   DOT_PACKAGES (space-separated; optional explicit packages)
#
# Hooks should be idempotent and print human-friendly logs; never write files
# outside the repo unless that's their purpose.

repo="$(cd "$(dirname "$0")" && pwd)"
cd "$repo"

os_raw="$(uname -s | tr '[:upper:]' '[:lower:]')"
case "$os_raw" in
  darwin) DOT_OS=darwin;;
  linux) DOT_OS=linux;;
  msys*|mingw*|cygwin*) DOT_OS=windows;;
  *) DOT_OS="$os_raw";;
esac

DOT_CMD=apply
DOT_DRYRUN=
DOT_TARGET="${HOME}"
DOT_PACKAGES=

usage(){ cat <<USAGE
dot – generic CLI
Usage:
  ./dot <apply|restow|delete|update|diff|test> [--dry-run] [--target DIR]
USAGE
}

if [ $# -gt 0 ]; then
  case "$1" in
    apply|restow|delete|update|diff|test) DOT_CMD="$1"; shift;;
    -h|--help) usage; exit 0;;
  esac
fi

while [ $# -gt 0 ]; do
  case "$1" in
    --dry-run|-n) DOT_DRYRUN=1; shift;;
    --target|-t) DOT_TARGET="$2"; shift 2;;
    -h|--help) usage; exit 0;;
    -*) echo "Unknown option: $1" >&2; usage; exit 2;;
    *) DOT_PACKAGES+=" $1"; shift;;
  esac
done

run_hooks() {
  local stage="$1"
  local root="${DOT_HOOKS:-$repo/scripts}"
  local -a plat
  plat=("common")
  case "$DOT_OS" in
    darwin|linux) plat+=("unix") ;;
  esac
  plat+=("$DOT_OS")

  local ran=0
  for p in "${plat[@]}"; do
    local dir="$root/$p/$stage"
    if [ -d "$dir" ]; then
      # Run in lexical order to allow numeric prefixes for ordering
      while IFS= read -r -d '' f; do
        echo "dot: running $p/$stage/$(basename "$f")"
        DOT_CMD="$DOT_CMD" DOT_OS="$DOT_OS" DOT_REPO="$repo" DOT_TARGET="$DOT_TARGET" DOT_DRYRUN="$DOT_DRYRUN" DOT_PACKAGES="$DOT_PACKAGES" bash "$f"
        ran=1
      done < <(find "$dir" -type f -maxdepth 1 -perm -u+x -print0 | sort -z)
    fi
  done
  if [ "$ran" = 0 ]; then
    echo "dot: no hooks for $stage (platforms: ${plat[*]})"
  fi
}

case "$DOT_CMD" in
  test)
    echo "dot test: running tests in ./tests if present"
    if [ -d "$repo/tests" ]; then
      if command -v npm >/dev/null 2>&1; then
        ( cd "$repo/tests" && npm install && npm test )
      else
        echo "npm not found; skipping tests" >&2
      fi
    else
      echo "no tests directory; nothing to do"
    fi
    ;;
  apply)
    run_hooks apply
    ;;
  restow)
    run_hooks restow
    ;;
  delete)
    run_hooks delete
    ;;
  update)
    if [ -d "$repo/.git" ]; then echo "dot: git pull --ff-only"; git -C "$repo" pull --ff-only || true; fi
    run_hooks restow
    ;;
  diff)
    DOT_DRYRUN=1
    run_hooks apply
    ;;
  *) usage; exit 2;;
esac
