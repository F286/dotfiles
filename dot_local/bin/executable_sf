#!/usr/bin/env bash
set -euo pipefail

# Optional: highlight the live query text in the preview (1=on, 0=off)
HIGHLIGHT_QUERY="${HIGHLIGHT_QUERY:-1}"

# --- smart path shortening (display-only) -----------------------------------
# SG_MAX_LABEL controls the visible width of the left item label.
# Default: half the terminal width (roughly the non-preview area).
: "${SG_MAX_LABEL:=$(( ${COLUMNS:-80} / 2 ))}"
: "${SG_ELLIPSIS:=…}"   # override with SG_ELLIPSIS=... if your font lacks '…'
TAB=$'\t'

# Accent color for matched text in optional preview highlight (256-color index)
# Used only if ripgrep is present for preview passthrough highlighting.
: "${SG_MATCH_COLOR:=111}"

# Optional initial query from args
# shellcheck disable=SC2034
QUERY="${*:-}"

# Toggle states (Alt-keys modify these)
FIXED=1        # Alt-r: fixed(1) <-> regex(0)     (git grep: -F vs -E)
WORD=0         # Alt-w: word boundary match       (git grep: -w)
SHOW_HIDDEN=0  # Alt-.: include hidden pathspecs  (exclude '**/.*' when 0)
NO_INDEX=0     # Alt-i: search all files (no-index) vs tracked-only
CASE_MODE=smart  # Alt-c: cycle smart -> sensitive -> ignore

# Match original behavior: search once query is non-empty
MIN_CHARS=1

# Hard requirements
for cmd in git fzf; do
  if ! command -v "$cmd" >/dev/null 2>&1; then
    echo "$cmd not found on PATH." >&2
    exit 0
  fi
done

# Determine search root - prefer git root, else project markers, else CWD
if ROOT="$(git -C "$PWD" rev-parse --show-toplevel 2>/dev/null)"; then
  :
else
  find_project_root() {
    local d="$PWD"
    local markers=(
      package.json pnpm-workspace.yaml yarn.lock package-lock.json
      go.mod Cargo.toml pyproject.toml requirements.txt
      composer.json Makefile CMakeLists.txt
    )
    while [ "$d" != "/" ]; do
      for m in "${markers[@]}"; do
        [ -e "$d/$m" ] && printf '%s' "$d" && return 0
      done
      d="$(dirname "$d")"
    done
    return 1
  }
  ROOT="${PWD}"
  if r="$(find_project_root)"; then ROOT="$r"; fi
fi
cd "$ROOT"

# --- Preview command ---------------------------------------------------------
# Centers around the hit with context and highlights the matched line.
# If rg is available and HIGHLIGHT_QUERY=1, also highlight query text in preview.
# IMPORTANT: leave {1},{2},{q} unquoted; fzf provides safe quoting.
# shellcheck disable=SC2016
PREVIEW_CMD='
  [ -z {2} ] && exit 0
  O={2}
  F=${O%%:*}
  L=${O#*:}; L=${L%%:*}; [ -z "$L" ] && L=1
  S=$((L>15 ? L-15 : 1))
  E=$((L+40))

  # Relative line number within the preview block
  R=$((L-S+1))

  _want_q_hl='"${HIGHLIGHT_QUERY}"'

  if command -v bat >/dev/null 2>&1; then
    if [ -n {q} ] && [ "$_want_q_hl" = "1" ] && command -v rg >/dev/null 2>&1; then
      bat --paging=never --style=plain --color=always \
          --line-range ${S}:${E} -- "$F" \
        | { rg --passthru --color=always --colors "match:fg:'"${SG_MATCH_COLOR}"'" -e {q} || true; } \
        | nl -ba -w1 -s"  " \
        | awk -v rel="$R" '"'"'NR==rel{ bg="\033[48;2;47;51;77m"; off="\033[49m"; if (match($0, /^[[:space:]]*[0-9]+  /)) { p=substr($0,1,RLENGTH); c=substr($0,RLENGTH+1); } else { p=""; c=$0; } c=bg c; gsub(/\033\[0m/, "\033[0m" bg, c); gsub(/\033\[49m/, bg, c); printf "%s%s%s\n", p, c, off; next }1'"'"'
    else
      bat --paging=never --style=plain --color=always \
          --line-range ${S}:${E} -- "$F" \
        | nl -ba -w1 -s"  " \
        | awk -v rel="$R" '"'"'NR==rel{ bg="\033[48;2;47;51;77m"; off="\033[49m"; if (match($0, /^[[:space:]]*[0-9]+  /)) { p=substr($0,1,RLENGTH); c=substr($0,RLENGTH+1); } else { p=""; c=$0; } c=bg c; gsub(/\033\[0m/, "\033[0m" bg, c); gsub(/\033\[49m/, bg, c); printf "%s%s%s\n", p, c, off; next }1'"'"'
    fi
  elif command -v batcat >/dev/null 2>&1; then
    if [ -n {q} ] && [ "$_want_q_hl" = "1" ] && command -v rg >/dev/null 2>&1; then
      batcat --paging=never --style=plain --color=always \
             --line-range ${S}:${E} -- "$F" \
        | { rg --passthru --color=always --colors "match:fg:'"${SG_MATCH_COLOR}"'" -e {q} || true; } \
        | nl -ba -w1 -s"  " \
        | awk -v rel="$R" '"'"'NR==rel{ bg="\033[48;2;47;51;77m"; off="\033[49m"; if (match($0, /^[[:space:]]*[0-9]+  /)) { p=substr($0,1,RLENGTH); c=substr($0,RLENGTH+1); } else { p=""; c=$0; } c=bg c; gsub(/\033\[0m/, "\033[0m" bg, c); gsub(/\033\[49m/, bg, c); printf "%s%s%s\n", p, c, off; next }1'"'"'
    else
      batcat --paging=never --style=plain --color=always \
             --line-range ${S}:${E} -- "$F" \
        | nl -ba -w1 -s"  " \
        | awk -v rel="$R" '"'"'NR==rel{ bg="\033[48;2;47;51;77m"; off="\033[49m"; if (match($0, /^[[:space:]]*[0-9]+  /)) { p=substr($0,1,RLENGTH); c=substr($0,RLENGTH+1); } else { p=""; c=$0; } c=bg c; gsub(/\033\[0m/, "\033[0m" bg, c); gsub(/\033\[49m/, bg, c); printf "%s%s%s\n", p, c, off; next }1'"'"'
    fi
  else
    if [ -n {q} ] && [ "$_want_q_hl" = "1" ] && command -v rg >/dev/null 2>&1; then
      sed -n "${S},${E}p" < "$F" | nl -ba -w1 -s"  " \
        | { rg --passthru --color=always --colors "match:fg:'"${SG_MATCH_COLOR}"'" -e {q} || true; } \
        | awk -v rel="$R" '"'"'NR==rel{ bg="\033[48;2;47;51;77m"; off="\033[49m"; if (match($0, /^[[:space:]]*[0-9]+  /)) { p=substr($0,1,RLENGTH); c=substr($0,RLENGTH+1); } else { p=""; c=$0; } c=bg c; gsub(/\033\[0m/, "\033[0m" bg, c); gsub(/\033\[49m/, bg, c); printf "%s%s%s\n", p, c, off; next }1'"'"'
    else
      sed -n "${S},${E}p" < "$F" | nl -ba -w1 -s"  " \
        | awk -v rel="$R" '"'"'NR==rel{ bg="\033[48;2;47;51;77m"; off="\033[49m"; if (match($0, /^[[:space:]]*[0-9]+  /)) { p=substr($0,1,RLENGTH); c=substr($0,RLENGTH+1); } else { p=""; c=$0; } c=bg c; gsub(/\033\[0m/, "\033[0m" bg, c); gsub(/\033\[49m/, bg, c); printf "%s%s%s\n", p, c, off; next }1'"'"'
    fi
  fi
'

HIST_DIR="${XDG_STATE_HOME:-$HOME/.local/state}/fzf-history"
mkdir -p "$HIST_DIR"
HIST_FILE="$HIST_DIR/sg"

# Run fzf in a loop to handle toggle keys, preserving query
while true; do
  # fzf reload snippet - only search when query is non-empty
  # IMPORTANT: leave {q} unquoted; fzf provides safe quoting.
  # We build flags for git grep in the subshell so we can implement "smart-case".
  # shellcheck disable=SC2034
  RELOAD_CMD='
    __FIXED='"$FIXED"'
    __WORD='"$WORD"'
    __SHOW_HIDDEN='"$SHOW_HIDDEN"'
    __NO_INDEX='"$NO_INDEX"'
    __CASE_MODE='"$CASE_MODE"'

    QLEN=$(printf %s {q} | wc -c | tr -d "\n ")
    if [ "${QLEN:-0}" -ge '"$MIN_CHARS"' ]; then
      cmd=(git -c color.grep=false -c core.quotepath=off grep -n --column -I)

      # Fixed vs regex (use -E for extended RE to be closer to ripgrep default regex)
      if [ "$__FIXED" -eq 1 ]; then
        cmd+=(-F)
      else
        cmd+=(-E)
      fi

      # Word match
      [ "$__WORD" -eq 1 ] && cmd+=(-w)

      # Case handling
      case "$__CASE_MODE" in
        ignore) cmd+=(-i) ;;
        sensitive) ;;
        smart)
          case {q} in *[A-Z]* ) ;; * ) cmd+=(-i) ;; esac
          ;;
      esac

      # Scope: tracked-only vs entire FS
      if [ "$__NO_INDEX" -eq 1 ]; then
        cmd+=(--no-index -- {q})
        # Pathspecs for no-index: always exclude .git; optionally exclude hidden files/dirs
        if [ "$__SHOW_HIDDEN" -eq 0 ]; then
          cmd+=(. ":(exclude,glob)**/.git/**" ":(exclude,glob)**/.*")
        else
          cmd+=(. ":(exclude,glob)**/.git/**")
        fi
      else
        # Tracked files (default). Use pathspecs to exclude hidden paths if requested.
        cmd+=(-- {q})
        if [ "$__SHOW_HIDDEN" -eq 0 ]; then
          cmd+=(. ":(exclude,glob)**/.*")
        else
          cmd+=(.)
        fi
      fi

      "${cmd[@]}" \
        | awk -v max='"$SG_MAX_LABEL"' -v E='"$SG_ELLIPSIS"' -F: '\''
            function shorten(path, max, E,    p, base, dir, n, i, seg, out, cand, head, name, ext, avail, left, right) {
              if (length(path) <= max) { return path }
              # split into dir + base
              p = 0
              for (i = length(path); i >= 1; i--) { if (substr(path,i,1) == "/") { p = i; break } }
              if (p == 0) {
                left = int((max - 1) / 2)
                right = max - 1 - left
                return substr(path,1,left) E substr(path,length(path)-right+1)
              }
              dir = substr(path,1,p-1)
              base = substr(path,p+1)
              # build from the right
              n = split(dir, arr, "/")
              out = base
              for (i = n; i >= 1; i--) {
                seg = arr[i]
                if (seg == "") continue
                cand = seg "/" out
                if (length(cand) + 2 <= max) { out = cand } else { break }
              }
              if (i >= 1) { out = E "/" out }
              if (length(out) > max) {
                # shrink basename in the middle
                p = 0
                for (i = length(out); i >= 1; i--) { if (substr(out,i,1) == "/") { p = i; break } }
                head = (p>0 ? substr(out,1,p-1) : "")
                name = (p>0 ? substr(out,p+1) : out)
                ext = ""
                for (i = length(name); i >= 1; i--) { if (substr(name,i,1) == ".") { ext = substr(name,i); name = substr(name,1,i-1); break } }
                avail = max - length(head) - 1
                if (avail < 5) { return substr(out, length(out)-max+1) }
                left = int((avail - length(ext) - 1) / 2)
                right = avail - length(ext) - 1 - left
                if (left < 1) left = 1
                if (right < 1) right = 1
                out = head "/" substr(name,1,left) E substr(name, length(name)-right+1) ext
              }
              return out
            }
            {
              file=$1
              line=$2
              col=$3
              label=shorten(file, max, E)
              rest=$0
              sub(/^[^:]*:/, "", rest)
              sub(/^[^:]*:/, "", rest)
              sub(/^[^:]*:/, "", rest)
              pathpos = file ":" line ":" col
              # Colors
              cpath="\033[38;2;86;95;137m"    # #565f89 for path
              cfile="\033[38;2;192;202;245m"  # #c0caf5 for filename
              cres="\033[0m"
              # split label into head/base
              p = 0
              for (i = length(label); i >= 1; i--) { if (substr(label,i,1) == "/") { p = i; break } }
              head = (p==0 ? "" : substr(label, 1, p))
              base = (p==0 ? label : substr(label, p+1))
              labelc = cpath head cres cfile base cres
              print labelc "\t" pathpos "\t" rest
            }
        '\'' || printf "::: \033[2mNo matches\033[0m\n"
    else
      printf ""
    fi
  '

  # shellcheck disable=SC2054
  FZF_ARGS=(
    --ansi
    --multi
    --phony # do not filter locally, we reload from git grep
    --bind "start:reload:${RELOAD_CMD}"
    --bind "change:reload:${RELOAD_CMD}"
    # LazyVim/TokyoNight-like prompt icon (requires Nerd Font; falls back harmlessly)
    --prompt='   '
    --height=100%
    --margin=1,2           # float-like feel
    --header=''            # keep clean like LazyVim floating picker
    --border --layout=reverse
    --info=inline # shows 1/65 on the right
    --delimiter=$'\t' --with-nth=1,3 --nth=2
    --preview="${PREVIEW_CMD}"
    --preview-window='right,60%,border,wrap'
    --preview-label=' Preview '
    --bind 'alt-p:toggle-preview'
    --bind 'ctrl-d:preview-half-page-down,ctrl-u:preview-half-page-up'
    --bind 'alt-a:toggle-all'
    # Open in VS Code at file:line:col
    --bind 'enter:execute-silent([ -n {2} ] && code -r --goto $(printf %s {2} | cut -d: -f1-3))+abort'
    --bind 'ctrl-q:execute-silent(printf %s\n {+2} | while IFS= read -r O; do code -r --goto "$(printf %s "$O" | cut -d: -f1-3)"; done)+abort'
    # TokyoNight Moon palette (close to LazyVim)
    --color='fg:#c0caf5,bg:#1e2030,fg+:#c0caf5,bg+:#2f334d,hl:#ff9e64,hl+:#ff9e64'
    --color='border:#3b4261,gutter:#1e2030'
    --color='spinner:#bb9af7,header:#565f89,pointer:#ff9e64,marker:#9ece6a'
    --color='prompt:#7aa2f7,query:#c0caf5,info:#565f89'
    --border-label "Grep - $(basename "$ROOT")"
    --history="$HIST_FILE"
    --print-query
  )

  out=$(FZF_DEFAULT_OPTS="${FZF_DEFAULT_OPTS-}" fzf \
    --expect=alt-r,alt-w,alt-.,alt-i,alt-c \
    "${FZF_ARGS[@]}" \
    --query "$QUERY" || true)

  key=$(printf '%s\n' "$out" | head -n1)
  QUERY=$(printf '%s\n' "$out" | sed -n '2p')
  case "$key" in
    alt-r) FIXED=$((1-FIXED));;           # regex<->fixed strings
    alt-w) WORD=$((1-WORD));;
    alt-.) SHOW_HIDDEN=$((1-SHOW_HIDDEN));;
    alt-i) NO_INDEX=$((1-NO_INDEX));;     # tracked-only <-> --no-index
    alt-c)
      case "$CASE_MODE" in
        smart) CASE_MODE=sensitive;;
        sensitive) CASE_MODE=ignore;;
        *) CASE_MODE=smart;;
      esac
      ;;
    *) break;;
  esac
done

exit 0

